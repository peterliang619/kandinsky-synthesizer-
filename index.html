<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Poetry Synthesizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: monospace;
            color: #fff;
        }

        /* Page System */
        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
        }

        .page.active {
            opacity: 1;
            pointer-events: all;
        }

        /* First Page */
        #first-page {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3;
        }

        #first-page h1 {
            font-size: 4rem;
            margin-bottom: 2rem;
            letter-spacing: 0.2rem;
        }

        #first-page .subtitle {
            font-size: 1.5rem;
            margin-bottom: 4rem;
            opacity: 0.7;
        }

        .btn {
            padding: 1rem 3rem;
            font-size: 1.2rem;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: monospace;
        }

        .btn:hover {
            background: #fff;
            color: #000;
        }

        /* About Page */
        #about-page {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2;
        }

        #about-page .content {
            max-width: 800px;
            text-align: center;
            padding: 2rem;
            z-index: 10;
            position: relative;
        }

        #about-page h2 {
            font-size: 3rem;
            margin-bottom: 2rem;
        }

        #about-page p {
            font-size: 1.2rem;
            line-height: 1.8;
            margin-bottom: 1.5rem;
            opacity: 0.9;
        }

        #about-page .play-btn {
            margin-top: 3rem;
        }

        /* Wave SVG */
        #wave-svg {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30vh;
            z-index: 1;
            transition: height 1.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #wave-svg.expanded {
            height: 60vh;
        }

        /* Synthesizer Page */
        #synthesizer-page {
            z-index: 1;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #synthesizer-container {
            position: absolute;
            bottom: -500px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            transition: bottom 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #synthesizer-container.rise {
            bottom: 20px;
        }

        #synthesizer-container svg {
            cursor: pointer;
        }

        [id^="key"] {
            cursor: pointer;
            transition: all 0.1s ease;
        }

        [id^="key"]:hover {
            filter: brightness(1.2);
        }

        [id^="key"]:active {
            filter: brightness(0.8);
        }

        /* Back button */
        .back-btn {
            position: absolute;
            top: 2rem;
            left: 2rem;
            padding: 0.5rem 1.5rem;
            font-size: 1rem;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: monospace;
            z-index: 200;
        }

        .back-btn:hover {
            background: #fff;
            color: #000;
        }
    </style>
</head>
<body>
    <!-- First Page -->
    <div id="first-page" class="page active">
        <h1>WAVE POETRY</h1>
        <div class="subtitle">An Interactive Synthesizer Experience</div>
        <button class="btn" onclick="goToAbout()">About</button>
    </div>

    <!-- About Page -->
    <div id="about-page" class="page">
        <div class="content">
            <h2>About</h2>
            <p>
                Wave Poetry Synthesizer is an interactive audiovisual experience where
                text transforms into flowing waves. Each key on the synthesizer triggers
                unique animations, creating a dynamic interplay between poetry and motion.
            </p>
            <p>
                The waves represent different stanzas of poetry, each with its own rhythm,
                amplitude, and character. Press the keys to explore the relationship between
                sound, text, and visual form.
            </p>
            <button class="btn play-btn" onclick="goToSynthesizer()">Play</button>
        </div>

        <!-- Vector Wave SVG -->
        <svg id="wave-svg" viewBox="0 0 1440 320" preserveAspectRatio="none">
            <path id="wave-path" fill="#ffffff" fill-opacity="0.1"
                d="M0,160L48,176C96,192,192,224,288,224C384,224,480,192,576,165.3C672,139,768,117,864,128C960,139,1056,181,1152,197.3C1248,213,1344,203,1392,197.3L1440,192L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z">
            </path>
        </svg>
    </div>

    <!-- Synthesizer Page -->
    <div id="synthesizer-page" class="page">
        <button class="back-btn" onclick="goToAbout()">‚Üê Back</button>
        <canvas id="canvas"></canvas>
        <div id="synthesizer-container"></div>
    </div>

    <script>
        // Page Navigation
        let currentPage = 'first-page';

        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
            currentPage = pageId;
        }

        function goToAbout() {
            showPage('about-page');
            // Animate wave rising
            setTimeout(() => {
                document.getElementById('wave-svg').classList.add('expanded');
            }, 100);
        }

        function goToSynthesizer() {
            showPage('synthesizer-page');
            // Start animation
            setTimeout(() => {
                initSynthesizer();
            }, 100);
            // Animate synthesizer rising
            setTimeout(() => {
                document.getElementById('synthesizer-container').classList.add('rise');
            }, 500);
        }

        // Canvas Setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Poem text - split into 4 waves
        const poem = {
            wave1: [
                "Fingers brush through air,",
                "Light unseen flickers across the screen,",
                "Every breath a melody unfinished,",
                "Waves folding, stacking, overflowing the edges of thought."
            ],
            wave2: [
                "Letters fall like droplets into the deep,",
                "Characters collide and resonate,",
                "Sound waves rebound in the chest,",
                "Colors shift from blue to orange to transparency,",
                "The sea flows through every unspoken idea."
            ],
            wave3: [
                "Memory slips away like sand pulled by retreating waves,",
                "Each letter a lingering shadow,",
                "Melody glimmers in the peripheral light,",
                "Peaks and troughs rearranging endlessly,",
                "Consciousness torn by wind, then smoothing again."
            ],
            wave4: [
                "The sea lies still, letters drifting,",
                "Each line an independent ripple,",
                "One key pressed, and the waves surge,",
                "Every crest echoes time,",
                "Every motion extends the heartbeat."
            ]
        };

        // Simplified pixel font (5x7 grid)
        const pixelFont = {
            'A': [[0,1,1,1,0],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1]],
            'B': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0]],
            'C': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]],
            'D': [[1,1,1,0,0],[1,0,0,1,0],[1,0,0,0,1],[1,0,0,1,0],[1,1,1,0,0]],
            'E': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,1,1,1]],
            'F': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0]],
            'G': [[0,1,1,1,0],[1,0,0,0,0],[1,0,1,1,1],[1,0,0,0,1],[0,1,1,1,0]],
            'H': [[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1]],
            'I': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
            'J': [[0,0,0,0,1],[0,0,0,0,1],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'K': [[1,0,0,0,1],[1,0,0,1,0],[1,1,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
            'L': [[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
            'M': [[1,0,0,0,1],[1,1,0,1,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'N': [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1]],
            'O': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'P': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0]],
            'Q': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,1,0],[0,1,1,0,1]],
            'R': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,1,0],[1,0,0,0,1]],
            'S': [[0,1,1,1,1],[1,0,0,0,0],[0,1,1,1,0],[0,0,0,0,1],[1,1,1,1,0]],
            'T': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
            'U': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'V': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0]],
            'W': [[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,1,0,1,1],[1,0,0,0,1]],
            'X': [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]],
            'Y': [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
            'Z': [[1,1,1,1,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,1,1,1,1]],
            ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
            ',': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,1,0,0,0]],
            '.': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0]],
            '!': [[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
            '?': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,1,0],[0,0,0,0,0],[0,0,1,0,0]],
            '-': [[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0]],
            ':': [[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0]],
            ';': [[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,1,0,0,0]]
        };

        // Convert text to circle points
        function textToCircles(text, startX, startY, circleSize = 2, spacing = 6) {
            const circles = [];
            let offsetX = startX;

            for (let char of text.toUpperCase()) {
                const pattern = pixelFont[char] || pixelFont[' '];

                for (let row = 0; row < pattern.length; row++) {
                    for (let col = 0; col < pattern[row].length; col++) {
                        if (pattern[row][col] === 1) {
                            circles.push({
                                x: offsetX + col * spacing,
                                y: startY + row * spacing,
                                baseX: offsetX + col * spacing,
                                baseY: startY + row * spacing,
                                size: circleSize,
                                baseSize: circleSize,
                                velocity: { x: 0, y: 0 },
                                alpha: 1
                            });
                        }
                    }
                }

                offsetX += (pattern[0].length + 1) * spacing;
            }

            return circles;
        }

        // Wave layers
        class WaveLayer {
            constructor(lines, yStart, color, waveParams) {
                this.lines = lines;
                this.yStart = yStart;
                this.color = color;
                this.amplitude = waveParams.amplitude || 20;
                this.frequency = waveParams.frequency || 0.01;
                this.phase = waveParams.phase || 0;
                this.speed = waveParams.speed || 1;
                this.circles = [];
                this.time = 0;
                this.active = true;

                // Generate circles for each line
                let yOffset = 0;
                for (let line of lines) {
                    const lineCircles = textToCircles(line, 100, yStart + yOffset, 2, 6);
                    this.circles.push(...lineCircles);
                    yOffset += 50;
                }
            }

            update(deltaTime) {
                this.time += deltaTime * this.speed * 0.001;

                // Update circle positions with wave motion
                for (let circle of this.circles) {
                    const waveOffset = Math.sin(circle.baseX * this.frequency + this.time + this.phase) * this.amplitude;
                    circle.y = circle.baseY + waveOffset;

                    // Add horizontal drift
                    circle.x = circle.baseX + Math.cos(this.time * 0.5) * 10;
                }
            }

            draw(ctx) {
                if (!this.active) return;

                ctx.fillStyle = this.color;
                for (let circle of this.circles) {
                    ctx.globalAlpha = circle.alpha;
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, circle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            // Effects triggered by keys
            burst(keyIndex) {
                const intensity = (keyIndex % 10) / 10;
                for (let circle of this.circles) {
                    const dx = circle.x - canvas.width / 2;
                    const dy = circle.y - canvas.height / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (1 - Math.min(dist / 500, 1)) * intensity * 50;
                    circle.velocity.x += (dx / dist) * force;
                    circle.velocity.y += (dy / dist) * force;
                }
            }

            ripple(keyIndex) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const rippleSpeed = 5 + (keyIndex % 5);

                for (let circle of this.circles) {
                    const dx = circle.x - centerX;
                    const dy = circle.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const delay = dist / rippleSpeed;

                    setTimeout(() => {
                        circle.size = circle.baseSize * 2;
                        setTimeout(() => {
                            circle.size = circle.baseSize;
                        }, 100);
                    }, delay);
                }
            }

            scatter() {
                for (let circle of this.circles) {
                    circle.velocity.x = (Math.random() - 0.5) * 20;
                    circle.velocity.y = (Math.random() - 0.5) * 20;
                }
            }

            gather() {
                for (let circle of this.circles) {
                    const dx = circle.baseX - circle.x;
                    const dy = circle.baseY - circle.y;
                    circle.velocity.x += dx * 0.1;
                    circle.velocity.y += dy * 0.1;
                }
            }

            applyVelocity() {
                for (let circle of this.circles) {
                    circle.x += circle.velocity.x;
                    circle.y += circle.velocity.y;

                    // Friction
                    circle.velocity.x *= 0.95;
                    circle.velocity.y *= 0.95;

                    // Spring back to base position
                    const dx = circle.baseX - circle.x;
                    const dy = circle.baseY - circle.y;
                    circle.velocity.x += dx * 0.01;
                    circle.velocity.y += dy * 0.01;
                }
            }
        }

        // Create wave layers
        let waves = [];
        let animationRunning = false;
        let lastTime = Date.now();
        let globalEffects = {
            turbulence: 0,
            zoom: 1,
            rotation: 0
        };

        function initSynthesizer() {
            if (animationRunning) return;

            waves = [
                new WaveLayer(poem.wave1, 50, '#ffffff', {
                    amplitude: 20,
                    frequency: 0.01,
                    phase: 0,
                    speed: 1
                }),
                new WaveLayer(poem.wave2, 250, '#ffffff', {
                    amplitude: 30,
                    frequency: 0.015,
                    phase: Math.PI / 4,
                    speed: 1.5
                }),
                new WaveLayer(poem.wave3, 450, '#ffffff', {
                    amplitude: 25,
                    frequency: 0.012,
                    phase: Math.PI / 2,
                    speed: 0.8
                }),
                new WaveLayer(poem.wave4, 650, '#ffffff', {
                    amplitude: 35,
                    frequency: 0.008,
                    phase: Math.PI,
                    speed: 1.2
                })
            ];

            animationRunning = true;
            animate();
            loadSynthesizer();
        }

        // Key effects mapping (40 keys)
        const keyEffects = {
            1: (wave) => { wave.amplitude *= 1.2; setTimeout(() => wave.amplitude /= 1.2, 500); },
            2: (wave) => { wave.amplitude *= 0.8; setTimeout(() => wave.amplitude /= 0.8, 500); },
            3: (wave) => { wave.frequency *= 1.5; setTimeout(() => wave.frequency /= 1.5, 500); },
            4: (wave) => { wave.frequency *= 0.7; setTimeout(() => wave.frequency /= 0.7, 500); },
            5: (wave) => { wave.speed *= 2; setTimeout(() => wave.speed /= 2, 500); },
            6: (wave) => { wave.speed *= 0.5; setTimeout(() => wave.speed /= 0.5, 500); },
            7: (wave) => { wave.phase += Math.PI / 4; },
            8: (wave) => { wave.phase -= Math.PI / 4; },
            9: (wave) => { wave.burst(9); },
            10: (wave) => { wave.ripple(10); },
            11: (wave) => { wave.scatter(); },
            12: (wave) => { wave.gather(); },
            13: (wave) => { for(let c of wave.circles) c.size *= 1.5; setTimeout(() => { for(let c of wave.circles) c.size /= 1.5; }, 300); },
            14: (wave) => { for(let c of wave.circles) c.size *= 0.5; setTimeout(() => { for(let c of wave.circles) c.size /= 0.5; }, 300); },
            15: (wave) => { for(let c of wave.circles) c.alpha = 0.3; setTimeout(() => { for(let c of wave.circles) c.alpha = 1; }, 300); },
            16: (wave) => { wave.active = !wave.active; setTimeout(() => wave.active = true, 500); },
            17: (wave) => { for(let c of wave.circles) c.baseX += 50; setTimeout(() => { for(let c of wave.circles) c.baseX -= 50; }, 500); },
            18: (wave) => { for(let c of wave.circles) c.baseX -= 50; setTimeout(() => { for(let c of wave.circles) c.baseX += 50; }, 500); },
            19: (wave) => { for(let c of wave.circles) c.baseY += 30; setTimeout(() => { for(let c of wave.circles) c.baseY -= 30; }, 500); },
            20: (wave) => { for(let c of wave.circles) c.baseY -= 30; setTimeout(() => { for(let c of wave.circles) c.baseY += 30; }, 500); },
            21: (wave) => { wave.burst(21); wave.amplitude *= 1.5; setTimeout(() => wave.amplitude /= 1.5, 500); },
            22: (wave) => { wave.ripple(22); wave.frequency *= 1.3; setTimeout(() => wave.frequency /= 1.3, 500); },
            23: (wave) => { wave.scatter(); wave.speed *= 2; setTimeout(() => wave.speed /= 2, 500); },
            24: (wave) => { wave.gather(); wave.phase += Math.PI / 2; },
            25: (wave) => { globalEffects.turbulence += 0.5; setTimeout(() => globalEffects.turbulence -= 0.5, 500); },
            26: (wave) => { globalEffects.zoom *= 1.2; setTimeout(() => globalEffects.zoom /= 1.2, 500); },
            27: (wave) => { globalEffects.zoom *= 0.8; setTimeout(() => globalEffects.zoom /= 0.8, 500); },
            28: (wave) => { globalEffects.rotation += 0.1; setTimeout(() => globalEffects.rotation -= 0.1, 500); },
            29: (wave) => { for(let c of wave.circles) { c.velocity.x = Math.sin(c.baseX * 0.01) * 30; } },
            30: (wave) => { for(let c of wave.circles) { c.velocity.y = Math.cos(c.baseY * 0.01) * 30; } },
            31: (wave) => { wave.amplitude = 50; wave.frequency = 0.02; setTimeout(() => { wave.amplitude = 20; wave.frequency = 0.01; }, 1000); },
            32: (wave) => { wave.amplitude = 5; wave.frequency = 0.05; setTimeout(() => { wave.amplitude = 20; wave.frequency = 0.01; }, 1000); },
            33: (wave) => { for(let c of wave.circles) { c.velocity.x = (Math.random() - 0.5) * 50; c.velocity.y = (Math.random() - 0.5) * 50; } },
            34: (wave) => { wave.ripple(34); for(let c of wave.circles) c.size *= 2; setTimeout(() => { for(let c of wave.circles) c.size /= 2; }, 400); },
            35: (wave) => { wave.burst(35); wave.scatter(); setTimeout(() => wave.gather(), 300); },
            36: (wave) => { wave.frequency *= 3; wave.amplitude *= 2; setTimeout(() => { wave.frequency /= 3; wave.amplitude /= 2; }, 600); },
            37: (wave) => { for(let c of wave.circles) c.alpha = Math.random(); setTimeout(() => { for(let c of wave.circles) c.alpha = 1; }, 400); },
            38: (wave) => { wave.phase += Math.PI; wave.speed *= -1; setTimeout(() => wave.speed *= -1, 1000); },
            39: (wave) => { for(let i = 0; i < wave.circles.length; i++) { setTimeout(() => { wave.circles[i].size *= 3; setTimeout(() => wave.circles[i].size /= 3, 100); }, i * 2); } },
            40: (wave) => { wave.burst(40); wave.ripple(40); wave.amplitude *= 2; setTimeout(() => wave.amplitude /= 2, 700); }
        };

        // Animation loop
        function animate() {
            if (!animationRunning || currentPage !== 'synthesizer-page') {
                requestAnimationFrame(animate);
                return;
            }

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply global transformations
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(globalEffects.zoom, globalEffects.zoom);
            ctx.rotate(globalEffects.rotation);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);

            // Update and draw waves
            for (let wave of waves) {
                wave.update(deltaTime);
                wave.applyVelocity();
                wave.draw(ctx);
            }

            ctx.restore();

            requestAnimationFrame(animate);
        }

        // Start animation loop for page transitions
        animate();

        // Load the OP-1 Field SVG synthesizer
        async function loadSynthesizer() {
            try {
                const response = await fetch('SVG');
                const svgText = await response.text();

                const container = document.getElementById('synthesizer-container');
                container.innerHTML = svgText;

                // Find all keys (key1-key40) and attach event listeners
                const keyNumbers = [];
                for (let i = 1; i <= 40; i++) {
                    const keyElement = document.getElementById(`key${i}`);
                    if (keyElement) {
                        keyNumbers.push(i);

                        // Make it clickable
                        keyElement.style.cursor = 'pointer';

                        // Add click event
                        keyElement.addEventListener('click', (e) => {
                            e.stopPropagation();
                            triggerKey(i);

                            // Visual feedback
                            keyElement.style.filter = 'brightness(1.5)';
                            setTimeout(() => {
                                keyElement.style.filter = '';
                            }, 150);
                        });
                    }
                }

                console.log(`Loaded OP-1 Field synthesizer with keys: ${keyNumbers.join(', ')}`);

            } catch (error) {
                console.error('Failed to load synthesizer SVG:', error);
            }
        }

        // Trigger key effect
        function triggerKey(keyNum) {
            const waveIndex = Math.floor((keyNum - 1) / 10);
            const wave = waves[Math.min(waveIndex, waves.length - 1)];

            if (keyEffects[keyNum]) {
                keyEffects[keyNum](wave);
            }
        }

        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (currentPage !== 'synthesizer-page') return;

            const keyMap = {
                '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '0': 10,
                'q': 11, 'w': 12, 'e': 13, 'r': 14, 't': 15, 'y': 16, 'u': 17, 'i': 18, 'o': 19, 'p': 20,
                'a': 21, 's': 22, 'd': 23, 'f': 24, 'g': 25, 'h': 26, 'j': 27, 'k': 28, 'l': 29, ';': 30,
                'z': 31, 'x': 32, 'c': 33, 'v': 34, 'b': 35, 'n': 36, 'm': 37, ',': 38, '.': 39, '/': 40
            };

            if (keyMap[e.key]) {
                triggerKey(keyMap[e.key]);
            }
        });

        console.log('üåä Wave Poetry Synthesizer Loaded');
        console.log('üìÑ Navigate: First Page ‚Üí About ‚Üí Synthesizer');
    </script>
</body>
</html>
