<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Poetry Synthesizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: monospace;
            color: #fff;
        }

        /* Page System */
        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .page.active {
            opacity: 1;
            pointer-events: all;
        }

        /* SVG Pages Container */
        .figma-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .figma-container svg {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Wave animation - rises when entering About page from First page */
        /* Start with wave at First page position (offset down) */
        #about-page svg {
            transition: transform 1.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Keep white background fixed */
        #about-page svg rect[fill="white"] {
            transform: translateY(0) !important;
        }

        /* Animate wave (black path) and text */
        #about-page svg path[fill="black"],
        #about-page svg text {
            transform: translateY(380px);
            transition: transform 1.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* When active and wave-rise class added, move to final position */
        #about-page.active.wave-rise svg path[fill="black"],
        #about-page.active.wave-rise svg text {
            transform: translateY(0);
        }

        /* Synthesizer Page */
        #synthesizer-page {
            z-index: 1;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #synthesizer-container {
            position: absolute;
            bottom: -500px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            transition: bottom 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: bottom;
        }

        #synthesizer-container.rise {
            bottom: 20px;
        }

        #synthesizer-container svg {
            cursor: pointer;
            max-width: 90vw;
            height: auto;
        }

        [id^="key"] {
            cursor: pointer;
            transition: all 0.1s ease;
        }

        [id^="key"]:hover {
            filter: brightness(1.2);
        }

        [id^="key"]:active {
            filter: brightness(0.8);
        }

        /* Buttons on Figma pages */
        .figma-button {
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .figma-button:hover {
            opacity: 0.8;
        }

        /* Back button */
        .back-btn {
            position: absolute;
            top: 2rem;
            left: 2rem;
            padding: 0.5rem 1.5rem;
            font-size: 1rem;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: monospace;
            z-index: 200;
        }

        .back-btn:hover {
            background: #fff;
            color: #000;
        }

        /* Back button icon only */
        .back-icon {
            position: absolute;
            top: 2rem;
            left: 2rem;
            width: 50px;
            height: 50px;
            background: transparent;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .back-icon::before {
            content: '';
            width: 12px;
            height: 12px;
            border-left: 2px solid #fff;
            border-bottom: 2px solid #fff;
            transform: rotate(45deg);
            margin-left: 4px;
            transition: border-color 0.3s ease;
        }

        .back-icon:hover {
            background: #fff;
        }

        .back-icon:hover::before {
            border-color: #000;
        }
    </style>
</head>
<body>
    <!-- First Page (Starting Page) -->
    <div id="first-page" class="page active">
        <div class="figma-container" id="first-figma"></div>
    </div>

    <!-- About Page -->
    <div id="about-page" class="page">
        <button class="back-icon" onclick="showPage('first-page')"></button>
        <div class="figma-container" id="about-figma"></div>
    </div>

    <!-- Synthesizer Page -->
    <div id="synthesizer-page" class="page">
        <button class="back-icon" onclick="showPage('first-page')"></button>
        <canvas id="canvas"></canvas>
        <div id="synthesizer-container"></div>
    </div>

    <script>
        // Page Navigation
        let currentPage = 'first-page';

        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
            currentPage = pageId;
        }

        // Load Figma SVG for both pages
        async function loadFigmaPages() {
            try {
                const response = await fetch('figma page design');
                const svgText = await response.text();

                // Parse the SVG
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');

                // Clone for First Page (starting page) - bottom section
                const firstPageSVG = svgDoc.documentElement.cloneNode(true);
                firstPageSVG.setAttribute('viewBox', '0 1480 2075 1117');
                firstPageSVG.removeAttribute('width');
                firstPageSVG.removeAttribute('height');
                firstPageSVG.setAttribute('preserveAspectRatio', 'xMidYMid slice');

                document.getElementById('first-figma').appendChild(firstPageSVG);

                // Add click detection based on coordinates
                // Upper half = Play (go to Synthesizer)
                // Lower half = About (go to About page)
                firstPageSVG.style.cursor = 'pointer';
                firstPageSVG.addEventListener('click', (e) => {
                    // Get click position relative to SVG
                    const rect = firstPageSVG.getBoundingClientRect();
                    const clickY = e.clientY - rect.top;
                    const svgHeight = rect.height;
                    const midPoint = svgHeight / 2;

                    console.log(`Click at Y: ${clickY}, midpoint: ${midPoint}`);

                    if (clickY < midPoint) {
                        // Upper half - Play
                        console.log('Upper half clicked - going to Synthesizer');
                        goToSynthesizer();
                    } else {
                        // Lower half - About
                        console.log('Lower half clicked - going to About page');
                        goToAbout();
                    }
                });

                // Clone for About Page - top section
                const aboutPageSVG = svgDoc.documentElement.cloneNode(true);
                aboutPageSVG.setAttribute('viewBox', '0 0 2075 1117');
                aboutPageSVG.removeAttribute('width');
                aboutPageSVG.removeAttribute('height');
                aboutPageSVG.setAttribute('preserveAspectRatio', 'xMidYMid slice');

                document.getElementById('about-figma').appendChild(aboutPageSVG);

                console.log('Figma pages loaded successfully');

            } catch (error) {
                console.error('Failed to load Figma SVG:', error);
            }
        }

        function goToAbout() {
            showPage('about-page');
            // Trigger wave rising animation after a short delay
            setTimeout(() => {
                const aboutPage = document.getElementById('about-page');
                aboutPage.classList.add('wave-rise');
            }, 100);
        }

        // Preload synthesizer SVG
        let synthesizerSVGLoaded = false;
        let synthesizerSVGContent = null;

        async function preloadSynthesizer() {
            try {
                const response = await fetch('SVG');
                synthesizerSVGContent = await response.text();
                synthesizerSVGLoaded = true;
                console.log('Synthesizer SVG preloaded');
            } catch (error) {
                console.error('Failed to preload synthesizer SVG:', error);
            }
        }

        function goToSynthesizer() {
            showPage('synthesizer-page');
            // Start animation
            setTimeout(() => {
                initSynthesizer();
            }, 100);
            // Animate synthesizer rising
            setTimeout(() => {
                document.getElementById('synthesizer-container').classList.add('rise');
            }, 500);
        }

        // Canvas Setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Poem text - split into 4 waves
        const poem = {
            wave1: [
                "Fingers brush through air,",
                "Light unseen flickers across the screen,",
                "Every breath a melody unfinished,",
                "Waves folding, stacking, overflowing the edges of thought."
            ],
            wave2: [
                "Letters fall like droplets into the deep,",
                "Characters collide and resonate,",
                "Sound waves rebound in the chest,",
                "Colors shift from blue to orange to transparency,",
                "The sea flows through every unspoken idea."
            ],
            wave3: [
                "Memory slips away like sand pulled by retreating waves,",
                "Each letter a lingering shadow,",
                "Melody glimmers in the peripheral light,",
                "Peaks and troughs rearranging endlessly,",
                "Consciousness torn by wind, then smoothing again."
            ],
            wave4: [
                "The sea lies still, letters drifting,",
                "Each line an independent ripple,",
                "One key pressed, and the waves surge,",
                "Every crest echoes time,",
                "Every motion extends the heartbeat."
            ]
        };

        // Simplified pixel font (5x7 grid)
        const pixelFont = {
            'A': [[0,1,1,1,0],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1]],
            'B': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0]],
            'C': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]],
            'D': [[1,1,1,0,0],[1,0,0,1,0],[1,0,0,0,1],[1,0,0,1,0],[1,1,1,0,0]],
            'E': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,1,1,1]],
            'F': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0]],
            'G': [[0,1,1,1,0],[1,0,0,0,0],[1,0,1,1,1],[1,0,0,0,1],[0,1,1,1,0]],
            'H': [[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1]],
            'I': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
            'J': [[0,0,0,0,1],[0,0,0,0,1],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'K': [[1,0,0,0,1],[1,0,0,1,0],[1,1,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
            'L': [[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
            'M': [[1,0,0,0,1],[1,1,0,1,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'N': [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1]],
            'O': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'P': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0]],
            'Q': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,1,0],[0,1,1,0,1]],
            'R': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,1,0],[1,0,0,0,1]],
            'S': [[0,1,1,1,1],[1,0,0,0,0],[0,1,1,1,0],[0,0,0,0,1],[1,1,1,1,0]],
            'T': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
            'U': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'V': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0]],
            'W': [[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,1,0,1,1],[1,0,0,0,1]],
            'X': [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]],
            'Y': [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
            'Z': [[1,1,1,1,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,1,1,1,1]],
            ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
            ',': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,1,0,0,0]],
            '.': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0]],
            '!': [[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
            '?': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,1,0],[0,0,0,0,0],[0,0,1,0,0]],
            '-': [[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0]],
            ':': [[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0]],
            ';': [[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,1,0,0,0]]
        };

        // Convert text to circle points
        function textToCircles(text, startX, startY, circleSize = 2, spacing = 6) {
            const circles = [];
            let offsetX = startX;

            for (let char of text.toUpperCase()) {
                const pattern = pixelFont[char] || pixelFont[' '];

                for (let row = 0; row < pattern.length; row++) {
                    for (let col = 0; col < pattern[row].length; col++) {
                        if (pattern[row][col] === 1) {
                            circles.push({
                                x: offsetX + col * spacing,
                                y: startY + row * spacing,
                                baseX: offsetX + col * spacing,
                                baseY: startY + row * spacing,
                                size: circleSize,
                                baseSize: circleSize,
                                velocity: { x: 0, y: 0 },
                                alpha: 1
                            });
                        }
                    }
                }

                offsetX += (pattern[0].length + 1) * spacing;
            }

            return circles;
        }

        // Wave layers
        class WaveLayer {
            constructor(lines, yStart, color, waveParams) {
                this.lines = lines;
                this.yStart = yStart;
                this.color = color;
                this.amplitude = waveParams.amplitude || 20;
                this.frequency = waveParams.frequency || 0.01;
                this.phase = waveParams.phase || 0;
                this.speed = waveParams.speed || 1;
                this.circles = [];
                this.time = 0;
                this.active = true;

                // Generate circles for each line
                let yOffset = 0;
                for (let line of lines) {
                    const lineCircles = textToCircles(line, 100, yStart + yOffset, 2, 6);
                    this.circles.push(...lineCircles);
                    yOffset += 50;
                }
            }

            update(deltaTime) {
                this.time += deltaTime * this.speed * 0.001;

                // Update circle positions with wave motion
                for (let circle of this.circles) {
                    const waveOffset = Math.sin(circle.baseX * this.frequency + this.time + this.phase) * this.amplitude;
                    circle.y = circle.baseY + waveOffset;

                    // Add horizontal drift
                    circle.x = circle.baseX + Math.cos(this.time * 0.5) * 10;
                }
            }

            draw(ctx) {
                if (!this.active) return;

                ctx.fillStyle = this.color;
                for (let circle of this.circles) {
                    ctx.globalAlpha = circle.alpha;
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, circle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            // Effects triggered by keys
            burst(keyIndex) {
                const intensity = (keyIndex % 10) / 10;
                for (let circle of this.circles) {
                    const dx = circle.x - canvas.width / 2;
                    const dy = circle.y - canvas.height / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (1 - Math.min(dist / 500, 1)) * intensity * 50;
                    circle.velocity.x += (dx / dist) * force;
                    circle.velocity.y += (dy / dist) * force;
                }
            }

            ripple(keyIndex) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const rippleSpeed = 5 + (keyIndex % 5);

                for (let circle of this.circles) {
                    const dx = circle.x - centerX;
                    const dy = circle.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const delay = dist / rippleSpeed;

                    setTimeout(() => {
                        circle.size = circle.baseSize * 2;
                        setTimeout(() => {
                            circle.size = circle.baseSize;
                        }, 100);
                    }, delay);
                }
            }

            scatter() {
                for (let circle of this.circles) {
                    circle.velocity.x = (Math.random() - 0.5) * 20;
                    circle.velocity.y = (Math.random() - 0.5) * 20;
                }
            }

            gather() {
                for (let circle of this.circles) {
                    const dx = circle.baseX - circle.x;
                    const dy = circle.baseY - circle.y;
                    circle.velocity.x += dx * 0.1;
                    circle.velocity.y += dy * 0.1;
                }
            }

            applyVelocity() {
                for (let circle of this.circles) {
                    circle.x += circle.velocity.x;
                    circle.y += circle.velocity.y;

                    // Friction
                    circle.velocity.x *= 0.95;
                    circle.velocity.y *= 0.95;

                    // Spring back to base position
                    const dx = circle.baseX - circle.x;
                    const dy = circle.baseY - circle.y;
                    circle.velocity.x += dx * 0.01;
                    circle.velocity.y += dy * 0.01;
                }
            }
        }

        // Create wave layers
        let waves = [];
        let animationRunning = false;
        let lastTime = Date.now();
        let globalEffects = {
            turbulence: 0,
            zoom: 1,
            rotation: 0
        };

        function initSynthesizer() {
            if (animationRunning) return;

            waves = [
                new WaveLayer(poem.wave1, 50, '#ffffff', {
                    amplitude: 20,
                    frequency: 0.01,
                    phase: 0,
                    speed: 1
                }),
                new WaveLayer(poem.wave2, 250, '#ffffff', {
                    amplitude: 30,
                    frequency: 0.015,
                    phase: Math.PI / 4,
                    speed: 1.5
                }),
                new WaveLayer(poem.wave3, 450, '#ffffff', {
                    amplitude: 25,
                    frequency: 0.012,
                    phase: Math.PI / 2,
                    speed: 0.8
                }),
                new WaveLayer(poem.wave4, 650, '#ffffff', {
                    amplitude: 35,
                    frequency: 0.008,
                    phase: Math.PI,
                    speed: 1.2
                })
            ];

            animationRunning = true;
            animate();
            loadSynthesizer();
        }

        // Key effects mapping (40 keys)
        const keyEffects = {
            1: (wave) => { wave.amplitude *= 1.2; setTimeout(() => wave.amplitude /= 1.2, 500); },
            2: (wave) => { wave.amplitude *= 0.8; setTimeout(() => wave.amplitude /= 0.8, 500); },
            3: (wave) => { wave.frequency *= 1.5; setTimeout(() => wave.frequency /= 1.5, 500); },
            4: (wave) => { wave.frequency *= 0.7; setTimeout(() => wave.frequency /= 0.7, 500); },
            5: (wave) => { wave.speed *= 2; setTimeout(() => wave.speed /= 2, 500); },
            6: (wave) => { wave.speed *= 0.5; setTimeout(() => wave.speed /= 0.5, 500); },
            7: (wave) => { wave.phase += Math.PI / 4; },
            8: (wave) => { wave.phase -= Math.PI / 4; },
            9: (wave) => { wave.burst(9); },
            10: (wave) => { wave.ripple(10); },
            11: (wave) => { wave.scatter(); },
            12: (wave) => { wave.gather(); },
            13: (wave) => { for(let c of wave.circles) c.size *= 1.5; setTimeout(() => { for(let c of wave.circles) c.size /= 1.5; }, 300); },
            14: (wave) => { for(let c of wave.circles) c.size *= 0.5; setTimeout(() => { for(let c of wave.circles) c.size /= 0.5; }, 300); },
            15: (wave) => { for(let c of wave.circles) c.alpha = 0.3; setTimeout(() => { for(let c of wave.circles) c.alpha = 1; }, 300); },
            16: (wave) => { wave.active = !wave.active; setTimeout(() => wave.active = true, 500); },
            17: (wave) => { for(let c of wave.circles) c.baseX += 50; setTimeout(() => { for(let c of wave.circles) c.baseX -= 50; }, 500); },
            18: (wave) => { for(let c of wave.circles) c.baseX -= 50; setTimeout(() => { for(let c of wave.circles) c.baseX += 50; }, 500); },
            19: (wave) => { for(let c of wave.circles) c.baseY += 30; setTimeout(() => { for(let c of wave.circles) c.baseY -= 30; }, 500); },
            20: (wave) => { for(let c of wave.circles) c.baseY -= 30; setTimeout(() => { for(let c of wave.circles) c.baseY += 30; }, 500); },
            21: (wave) => { wave.burst(21); wave.amplitude *= 1.5; setTimeout(() => wave.amplitude /= 1.5, 500); },
            22: (wave) => { wave.ripple(22); wave.frequency *= 1.3; setTimeout(() => wave.frequency /= 1.3, 500); },
            23: (wave) => { wave.scatter(); wave.speed *= 2; setTimeout(() => wave.speed /= 2, 500); },
            24: (wave) => { wave.gather(); wave.phase += Math.PI / 2; },
            25: (wave) => { globalEffects.turbulence += 0.5; setTimeout(() => globalEffects.turbulence -= 0.5, 500); },
            26: (wave) => { globalEffects.zoom *= 1.2; setTimeout(() => globalEffects.zoom /= 1.2, 500); },
            27: (wave) => { globalEffects.zoom *= 0.8; setTimeout(() => globalEffects.zoom /= 0.8, 500); },
            28: (wave) => { globalEffects.rotation += 0.1; setTimeout(() => globalEffects.rotation -= 0.1, 500); },
            29: (wave) => { for(let c of wave.circles) { c.velocity.x = Math.sin(c.baseX * 0.01) * 30; } },
            30: (wave) => { for(let c of wave.circles) { c.velocity.y = Math.cos(c.baseY * 0.01) * 30; } },
            31: (wave) => { wave.amplitude = 50; wave.frequency = 0.02; setTimeout(() => { wave.amplitude = 20; wave.frequency = 0.01; }, 1000); },
            32: (wave) => { wave.amplitude = 5; wave.frequency = 0.05; setTimeout(() => { wave.amplitude = 20; wave.frequency = 0.01; }, 1000); },
            33: (wave) => { for(let c of wave.circles) { c.velocity.x = (Math.random() - 0.5) * 50; c.velocity.y = (Math.random() - 0.5) * 50; } },
            34: (wave) => { wave.ripple(34); for(let c of wave.circles) c.size *= 2; setTimeout(() => { for(let c of wave.circles) c.size /= 2; }, 400); },
            35: (wave) => { wave.burst(35); wave.scatter(); setTimeout(() => wave.gather(), 300); },
            36: (wave) => { wave.frequency *= 3; wave.amplitude *= 2; setTimeout(() => { wave.frequency /= 3; wave.amplitude /= 2; }, 600); },
            37: (wave) => { for(let c of wave.circles) c.alpha = Math.random(); setTimeout(() => { for(let c of wave.circles) c.alpha = 1; }, 400); },
            38: (wave) => { wave.phase += Math.PI; wave.speed *= -1; setTimeout(() => wave.speed *= -1, 1000); },
            39: (wave) => { for(let i = 0; i < wave.circles.length; i++) { setTimeout(() => { wave.circles[i].size *= 3; setTimeout(() => wave.circles[i].size /= 3, 100); }, i * 2); } },
            40: (wave) => { wave.burst(40); wave.ripple(40); wave.amplitude *= 2; setTimeout(() => wave.amplitude /= 2, 700); }
        };

        // Animation loop
        function animate() {
            if (!animationRunning || currentPage !== 'synthesizer-page') {
                requestAnimationFrame(animate);
                return;
            }

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply global transformations
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(globalEffects.zoom, globalEffects.zoom);
            ctx.rotate(globalEffects.rotation);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);

            // Update and draw waves
            for (let wave of waves) {
                wave.update(deltaTime);
                wave.applyVelocity();
                wave.draw(ctx);
            }

            ctx.restore();

            requestAnimationFrame(animate);
        }

        // Start animation loop for page transitions
        animate();

        // Load the OP-1 Field SVG synthesizer
        async function loadSynthesizer() {
            try {
                const container = document.getElementById('synthesizer-container');

                // Use preloaded content if available, otherwise fetch
                let svgText;
                if (synthesizerSVGLoaded && synthesizerSVGContent) {
                    svgText = synthesizerSVGContent;
                } else {
                    const response = await fetch('SVG');
                    svgText = await response.text();
                }

                container.innerHTML = svgText;

                // Find all keys (key1-key40) and attach event listeners
                const keyNumbers = [];
                for (let i = 1; i <= 40; i++) {
                    const keyElement = document.getElementById(`key${i}`);
                    if (keyElement) {
                        keyNumbers.push(i);

                        // Make it clickable
                        keyElement.style.cursor = 'pointer';

                        // Add click event
                        keyElement.addEventListener('click', (e) => {
                            e.stopPropagation();
                            triggerKey(i);

                            // Visual feedback
                            keyElement.style.filter = 'brightness(1.5)';
                            setTimeout(() => {
                                keyElement.style.filter = '';
                            }, 150);
                        });
                    }
                }

                console.log(`Loaded OP-1 Field synthesizer with keys: ${keyNumbers.join(', ')}`);

            } catch (error) {
                console.error('Failed to load synthesizer SVG:', error);
            }
        }

        // Audio context for synthesizer sounds
        let audioContext = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Play sound for key
        function playKeySound(keyNum) {
            initAudio();

            // Calculate frequency based on key number (chromatic scale starting from C3)
            const baseFreq = 130.81; // C3
            const semitone = Math.pow(2, 1/12);
            const frequency = baseFreq * Math.pow(semitone, keyNum - 1);

            // Create oscillator
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Set waveform (vary by key for diversity)
            const waveforms = ['sine', 'square', 'sawtooth', 'triangle'];
            oscillator.type = waveforms[Math.floor((keyNum - 1) / 10) % waveforms.length];

            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            // Envelope
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

            // Play
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // Trigger key effect
        function triggerKey(keyNum) {
            const waveIndex = Math.floor((keyNum - 1) / 10);
            const wave = waves[Math.min(waveIndex, waves.length - 1)];

            if (keyEffects[keyNum]) {
                keyEffects[keyNum](wave);
            }

            // Play sound
            playKeySound(keyNum);
        }

        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (currentPage !== 'synthesizer-page') return;

            const keyMap = {
                '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '0': 10,
                'q': 11, 'w': 12, 'e': 13, 'r': 14, 't': 15, 'y': 16, 'u': 17, 'i': 18, 'o': 19, 'p': 20,
                'a': 21, 's': 22, 'd': 23, 'f': 24, 'g': 25, 'h': 26, 'j': 27, 'k': 28, 'l': 29, ';': 30,
                'z': 31, 'x': 32, 'c': 33, 'v': 34, 'b': 35, 'n': 36, 'm': 37, ',': 38, '.': 39, '/': 40
            };

            if (keyMap[e.key]) {
                triggerKey(keyMap[e.key]);
            }
        });

        // Load Figma pages on startup
        loadFigmaPages().then(() => {
            // Preload synthesizer in the background after Figma pages load
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => preloadSynthesizer());
            } else {
                setTimeout(() => preloadSynthesizer(), 1000);
            }
        });

        console.log('ðŸŒŠ Wave Poetry Synthesizer with Figma Designs');
        console.log('ðŸ“„ Navigate: First Page (Start) â†’ About (Wave Rise) OR Play â†’ Synthesizer');
    </script>
</body>
</html>
